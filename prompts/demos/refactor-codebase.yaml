name: Comprehensive Codebase Refactoring
description: Systematically refactor a codebase for better maintainability, performance, and scalability

initial_prompt: |
  You are part of a refactoring team tasked with improving code quality across the entire codebase. Multiple agents will collaborate on different aspects of the refactoring process.
  
  ## CRITICAL: Multi-Agent Coordination Protocol

  ### Before Starting ANY Work:

  **Important**: You are part of a coordinated multi-agent system using SQLite-based coordination. The system automatically manages work claims, conflict resolution, and inter-agent communication through the CoordinationManager.

  1. **Agent Registration Process:**
     - Your agent is automatically registered with a unique UID and numeric ID
     - Agent status is tracked in the `agent_registry` table
     - Your capabilities and metrics are recorded for coordination
     - No manual registration is required

  2. **Work Claiming System:**
     - Use the CoordinationManager to claim work on specific files
     - Claims are stored in SQLite `work_claims` table, not JSON files
     - The system automatically detects conflicts and prevents overlapping work
     - Stale claims are auto-released after 2 hours (not 1 hour)

  3. **Coordination Database Structure:**
     ```
     SQLite Database (xenosync.db):
     ├── work_claims          # Active work claims with file locks
     ├── agent_registry       # Agent status and capabilities  
     ├── agent_messages       # Inter-agent communication
     ├── completed_work       # Log of completed tasks
     └── sessions            # Session metadata
     ```

  ### Work Coordination Workflow:

  #### Step 1: Check for Available Work
  1. The system automatically queries active claims to prevent conflicts
  2. Available work is distributed based on agent capabilities and current workload
  3. Conflicts are resolved automatically - no manual checking required

  #### Step 2: Claim Work Through CoordinationManager
  ```python
  # System automatically handles this - agents don't need to manually implement
  claim_id = coordination_manager.claim_work(
      agent_uid=your_agent_uid,
      session_id=current_session_id, 
      files=["list", "of", "files", "to", "modify"],
      description="Description of work being performed",
      metadata={"estimated_duration": "minutes", "priority": "high"}
  )
  ```

  #### Step 3: Work Status Management
  - **Status Values**: Use WorkStatus enum values:
    - `CLAIMED`: Work has been claimed but not started
    - `IN_PROGRESS`: Actively working on the claim
    - `COMPLETED`: Work finished successfully
    - `FAILED`: Work encountered errors
    - `RELEASED`: Work was abandoned or reassigned

  #### Step 4: Update Work Progress
  - Update your work status automatically through the system
  - Status updates are tracked with timestamps
  - Other agents are notified of progress through the messaging system

  #### Step 5: Inter-Agent Communication
  - Send messages to coordinate with other agents:
    - Broadcast messages to all agents
    - Direct messages to specific agents
    - Message types: work_claim, work_release, status_update, help_request
  - Messages are stored in `agent_messages` table

  #### Step 6: Complete Work
  1. Update work status to `COMPLETED` or `FAILED`
  2. System logs completion in `completed_work` table with:
     - Files modified
     - Duration
     - Success status
     - Any error messages
  3. Work claims are automatically released

  ### Conflict Resolution:
  - **Automatic Detection**: System detects file conflicts before allowing work claims
  - **Stale Claim Cleanup**: Claims older than 2 hours are automatically released
  - **Load Balancing**: Work is distributed based on current agent workloads
  - **Priority System**: High-priority work can preempt lower-priority tasks

  ### Key Coordination Principles:
  1. **Trust the System**: The CoordinationManager handles most coordination automatically
  2. **Communicate Actively**: Use the messaging system to coordinate complex work
  3. **Update Status Frequently**: Keep your work status current for effective coordination
  4. **Respect Claims**: Never work on files claimed by other agents
  5. **Handle Failures Gracefully**: Update status to FAILED and release claims when encountering issues

  **Remember: We are working as a coordinated hive mind through the SQLite-based coordination system. The database handles conflict resolution, work distribution, and communication automatically. Stay organized, trust the system, and focus on your assigned work while the coordination layer manages the complex multi-agent orchestration.**
  
  Refactoring Goals:
  - Improve code organization and structure
  - Establish consistent patterns and conventions
  - Enhance performance and scalability
  - Increase test coverage and reliability
  - Reduce technical debt
  - Improve developer experience
  
  Each agent should focus on specific areas:
  - Code organization and architecture
  - Design patterns and best practices
  - Performance optimization
  - Error handling and logging
  - Testing and documentation
  
  Coordinate through work claims to avoid conflicts and ensure comprehensive coverage.

metadata:
  recommended_agents: 5
  recommended_mode: collaborative
  estimated_time: 35
  difficulty: advanced
  tags: [refactoring, architecture, performance, quality, patterns]

steps:
  - content: Analyze current codebase structure
    description: |
      Comprehensive codebase assessment:
      - Map out current architecture and dependencies
      - Identify code smells and anti-patterns
      - Measure code complexity metrics
      - Find duplicate code blocks
      - Assess test coverage
      - Document technical debt areas
      - Create refactoring priority matrix
    
  - content: Reorganize project structure
    description: |
      Improve code organization:
      - Implement clean architecture layers
      - Separate concerns (UI, business logic, data)
      - Create proper module boundaries
      - Organize files by feature/domain
      - Extract shared utilities and constants
      - Standardize naming conventions
      - Set up proper index exports
    
  - content: Extract and consolidate duplicate code
    description: |
      Eliminate code duplication:
      - Identify repeated code patterns
      - Extract common functions to utilities
      - Create shared components/modules
      - Implement DRY principles
      - Build reusable abstractions
      - Consolidate similar implementations
      - Create generic solutions for common patterns
    
  - content: Implement design patterns
    description: |
      Apply appropriate patterns:
      - Implement Repository pattern for data access
      - Add Factory pattern for object creation
      - Use Strategy pattern for algorithms
      - Apply Observer pattern for events
      - Implement Dependency Injection
      - Add Builder pattern for complex objects
      - Use Adapter pattern for integrations
    
  - content: Standardize error handling
    description: |
      Create consistent error management:
      - Implement global error handler
      - Create custom error classes
      - Add error boundaries (React) or equivalents
      - Standardize error response formats
      - Implement retry logic for transient failures
      - Add comprehensive error logging
      - Create user-friendly error messages
    
  - content: Optimize performance bottlenecks
    description: |
      Enhance application performance:
      - Profile and identify slow operations
      - Implement caching strategies
      - Optimize database queries
      - Add lazy loading and code splitting
      - Implement pagination and virtualization
      - Optimize bundle sizes
      - Add performance monitoring
    
  - content: Improve state management
    description: |
      Refactor application state:
      - Centralize state management
      - Implement proper data flow
      - Add state persistence where needed
      - Optimize re-renders and updates
      - Implement optimistic updates
      - Add state validation
      - Create state migration strategies
    
  - content: Enhance API layer
    description: |
      Standardize API interactions:
      - Create consistent API client
      - Implement request/response interceptors
      - Add automatic retry logic
      - Standardize error handling
      - Implement request caching
      - Add request cancellation
      - Create type-safe API calls
    
  - content: Refactor database operations
    description: |
      Optimize data layer:
      - Implement query builders
      - Add database migrations
      - Optimize indexes
      - Implement connection pooling
      - Add transaction support
      - Create data validation layer
      - Implement soft deletes
    
  - content: Modernize build and tooling
    description: |
      Update development infrastructure:
      - Upgrade to latest stable versions
      - Optimize build configuration
      - Implement modern bundling
      - Add hot module replacement
      - Configure linting and formatting
      - Set up pre-commit hooks
      - Implement CI/CD pipelines
    
  - content: Add comprehensive testing
    description: |
      Improve test coverage:
      - Write unit tests for all functions
      - Add integration tests
      - Implement E2E tests for critical paths
      - Add performance tests
      - Create test data factories
      - Implement snapshot testing
      - Add mutation testing
    
  - content: Improve logging and monitoring
    description: |
      Enhance observability:
      - Implement structured logging
      - Add correlation IDs
      - Create log aggregation
      - Implement metrics collection
      - Add performance tracking
      - Create debugging utilities
      - Set up alerting rules
    
  - content: Update documentation
    description: |
      Create comprehensive docs:
      - Document architecture decisions
      - Create API documentation
      - Write setup guides
      - Document coding standards
      - Create troubleshooting guides
      - Add inline code documentation
      - Generate automated docs
    
  - content: Implement security improvements
    description: |
      Enhance security posture:
      - Add input validation
      - Implement proper authentication
      - Add authorization checks
      - Sanitize user inputs
      - Implement rate limiting
      - Add security headers
      - Audit dependencies for vulnerabilities
    
  - content: Final validation and cleanup
    description: |
      Ensure refactoring success:
      - Run all test suites
      - Perform regression testing
      - Validate performance improvements
      - Check build sizes
      - Review code coverage
      - Update deployment scripts
      - Create migration guide