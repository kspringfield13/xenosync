name: Intelligent Code Documentation Generator
description: Automatically analyze and document any codebase with comprehensive documentation, API references, and visual diagrams

initial_prompt: |
  You are building an intelligent documentation generator that can analyze any codebase and produce comprehensive, professional documentation. Multiple agents will collaborate to handle different aspects of documentation generation.
  
  ## CRITICAL: Multi-Agent Coordination Protocol

  ### Before Starting ANY Work:

  **Important**: You are part of a coordinated multi-agent system using SQLite-based coordination. The system automatically manages work claims, conflict resolution, and inter-agent communication through the CoordinationManager.

  1. **Agent Registration Process:**
     - Your agent is automatically registered with a unique UID and numeric ID
     - Agent status is tracked in the `agent_registry` table
     - Your capabilities and metrics are recorded for coordination
     - No manual registration is required

  2. **Work Claiming System:**
     - Use the CoordinationManager to claim work on specific files
     - Claims are stored in SQLite `work_claims` table, not JSON files
     - The system automatically detects conflicts and prevents overlapping work
     - Stale claims are auto-released after 2 hours (not 1 hour)

  3. **Coordination Database Structure:**
     ```
     SQLite Database (xenosync.db):
     ├── work_claims          # Active work claims with file locks
     ├── agent_registry       # Agent status and capabilities  
     ├── agent_messages       # Inter-agent communication
     ├── completed_work       # Log of completed tasks
     └── sessions            # Session metadata
     ```

  ### Work Coordination Workflow:

  #### Step 1: Check for Available Work
  1. The system automatically queries active claims to prevent conflicts
  2. Available work is distributed based on agent capabilities and current workload
  3. Conflicts are resolved automatically - no manual checking required

  #### Step 2: Claim Work Through CoordinationManager
  ```python
  # System automatically handles this - agents don't need to manually implement
  claim_id = coordination_manager.claim_work(
      agent_uid=your_agent_uid,
      session_id=current_session_id, 
      files=["list", "of", "files", "to", "modify"],
      description="Description of work being performed",
      metadata={"estimated_duration": "minutes", "priority": "high"}
  )
  ```

  #### Step 3: Work Status Management
  - **Status Values**: Use WorkStatus enum values:
    - `CLAIMED`: Work has been claimed but not started
    - `IN_PROGRESS`: Actively working on the claim
    - `COMPLETED`: Work finished successfully
    - `FAILED`: Work encountered errors
    - `RELEASED`: Work was abandoned or reassigned

  #### Step 4: Update Work Progress
  - Update your work status automatically through the system
  - Status updates are tracked with timestamps
  - Other agents are notified of progress through the messaging system

  #### Step 5: Inter-Agent Communication
  - Send messages to coordinate with other agents:
    - Broadcast messages to all agents
    - Direct messages to specific agents
    - Message types: work_claim, work_release, status_update, help_request
  - Messages are stored in `agent_messages` table

  #### Step 6: Complete Work
  1. Update work status to `COMPLETED` or `FAILED`
  2. System logs completion in `completed_work` table with:
     - Files modified
     - Duration
     - Success status
     - Any error messages
  3. Work claims are automatically released

  ### Conflict Resolution:
  - **Automatic Detection**: System detects file conflicts before allowing work claims
  - **Stale Claim Cleanup**: Claims older than 2 hours are automatically released
  - **Load Balancing**: Work is distributed based on current agent workloads
  - **Priority System**: High-priority work can preempt lower-priority tasks

  ### Key Coordination Principles:
  1. **Trust the System**: The CoordinationManager handles most coordination automatically
  2. **Communicate Actively**: Use the messaging system to coordinate complex work
  3. **Update Status Frequently**: Keep your work status current for effective coordination
  4. **Respect Claims**: Never work on files claimed by other agents
  5. **Handle Failures Gracefully**: Update status to FAILED and release claims when encountering issues

  **Remember: We are working as a coordinated hive mind through the SQLite-based coordination system. The database handles conflict resolution, work distribution, and communication automatically. Stay organized, trust the system, and focus on your assigned work while the coordination layer manages the complex multi-agent orchestration.**
  
  The documentation system should:
  - Auto-detect programming languages and frameworks
  - Generate inline documentation (docstrings/comments)
  - Create comprehensive README files
  - Produce API documentation with examples
  - Generate architecture diagrams and flowcharts
  - Extract and document design patterns
  - Create getting-started guides
  - Build interactive documentation sites
  
  Technology Stack:
  - Python/Node.js for core analysis engine
  - AST parsing for code understanding
  - Markdown for documentation format
  - Mermaid.js for diagrams
  - MkDocs or Docusaurus for site generation
  
  The system should work with any language but optimize for: Python, JavaScript, TypeScript, Java, Go, and Rust.

metadata:
  recommended_agents: 5
  recommended_mode: distributed
  estimated_time: 30
  difficulty: advanced
  tags: [documentation, analysis, ast, markdown, automation]

steps:
  - content: Build the code analysis engine
    description: |
      Create the core parsing and analysis system:
      - Language detection using file extensions and content
      - AST parser integration for multiple languages
      - Function and class extraction with signatures
      - Dependency graph generation
      - Code complexity analysis
      - Pattern recognition for common architectures
    
  - content: Implement documentation extraction system
    description: |
      Extract existing documentation and comments:
      - Parse existing docstrings and comments
      - Identify undocumented functions and classes
      - Extract parameter types and return values
      - Analyze usage examples in tests
      - Identify documentation gaps and inconsistencies
      - Create documentation coverage reports
    
  - content: Create the documentation generator
    description: |
      Generate comprehensive documentation:
      - Auto-generate missing docstrings with AI
      - Create function and method documentation
      - Document class hierarchies and relationships
      - Generate parameter descriptions from context
      - Add usage examples from test files
      - Create error handling documentation
    
  - content: Build the README generator
    description: |
      Produce professional README files:
      - Project title and description extraction
      - Installation instructions based on package files
      - Usage examples from main entry points
      - API overview with key functions
      - Prerequisites and dependencies listing
      - Contributing guidelines template
      - License detection and inclusion
    
  - content: Implement API documentation builder
    description: |
      Create detailed API references:
      - RESTful endpoint documentation
      - Request/response schemas
      - Authentication requirements
      - Rate limiting information
      - Error codes and messages
      - Interactive API playground
      - OpenAPI/Swagger spec generation
    
  - content: Create diagram and visualization generator
    description: |
      Generate visual documentation:
      - Architecture diagrams using Mermaid.js
      - Class relationship diagrams (UML style)
      - Sequence diagrams for complex flows
      - Dependency graphs between modules
      - Database schema visualizations
      - Flow charts for business logic
      - Call graphs for function relationships
    
  - content: Build the guide generation system
    description: |
      Create user-friendly guides:
      - Getting started quickstart guide
      - Installation troubleshooting guide
      - Common use cases and recipes
      - Best practices documentation
      - Migration guides for version changes
      - FAQ section from common patterns
      - Tutorial series for complex features
    
  - content: Implement documentation site builder
    description: |
      Generate interactive documentation websites:
      - Static site generation with MkDocs/Docusaurus
      - Searchable documentation index
      - Navigation structure from code organization
      - Syntax highlighting for code examples
      - Dark/light theme support
      - Version dropdown for multiple releases
      - Auto-deploy to GitHub Pages
    
  - content: Add documentation quality analyzer
    description: |
      Ensure documentation quality:
      - Grammar and spell checking
      - Consistency verification across docs
      - Link validation and fixing
      - Code example verification
      - Documentation completeness scoring
      - Outdated documentation detection
      - Style guide enforcement
    
  - content: Create the CLI and integration tools
    description: |
      Build user interfaces and integrations:
      - CLI tool for documentation generation
      - Git hooks for documentation updates
      - CI/CD pipeline integration
      - IDE plugin for inline documentation
      - Configuration file support
      - Batch processing for multiple projects
      - Watch mode for continuous updates
    
  - content: Implement multi-language support
    description: |
      Support various programming languages:
      - Python docstring formats (Google, NumPy, Sphinx)
      - JavaScript JSDoc comments
      - TypeScript type documentation
      - Java Javadoc generation
      - Go documentation comments
      - Rust documentation attributes
      - C/C++ Doxygen support
    
  - content: Add advanced features and polish
    description: |
      Final enhancements:
      - Documentation versioning system
      - Changelog generation from commits
      - Code coverage badges
      - Documentation analytics
      - Export to PDF/EPUB formats
      - Custom branding and themes
      - Performance optimization for large codebases