name: Cross-Platform Mobile Application Development
description: Build a complete mobile application with React Native or Flutter, including UI, state management, and native features

initial_prompt: |
  You are building a cross-platform mobile application that runs on both iOS and Android. Multiple agents will collaborate on different aspects of the app development.
  
  ## CRITICAL: Multi-Agent Coordination Protocol

  ### Before Starting ANY Work:

  **Important**: You are part of a coordinated multi-agent system using SQLite-based coordination. The system automatically manages work claims, conflict resolution, and inter-agent communication through the CoordinationManager.

  1. **Agent Registration Process:**
     - Your agent is automatically registered with a unique UID and numeric ID
     - Agent status is tracked in the `agent_registry` table
     - Your capabilities and metrics are recorded for coordination
     - No manual registration is required

  2. **Work Claiming System:**
     - Use the CoordinationManager to claim work on specific files
     - Claims are stored in SQLite `work_claims` table, not JSON files
     - The system automatically detects conflicts and prevents overlapping work
     - Stale claims are auto-released after 2 hours (not 1 hour)

  3. **Coordination Database Structure:**
     ```
     SQLite Database (xenosync.db):
     ├── work_claims          # Active work claims with file locks
     ├── agent_registry       # Agent status and capabilities  
     ├── agent_messages       # Inter-agent communication
     ├── completed_work       # Log of completed tasks
     └── sessions            # Session metadata
     ```

  ### Work Coordination Workflow:

  #### Step 1: Check for Available Work
  1. The system automatically queries active claims to prevent conflicts
  2. Available work is distributed based on agent capabilities and current workload
  3. Conflicts are resolved automatically - no manual checking required

  #### Step 2: Claim Work Through CoordinationManager
  ```python
  # System automatically handles this - agents don't need to manually implement
  claim_id = coordination_manager.claim_work(
      agent_uid=your_agent_uid,
      session_id=current_session_id, 
      files=["list", "of", "files", "to", "modify"],
      description="Description of work being performed",
      metadata={"estimated_duration": "minutes", "priority": "high"}
  )
  ```

  #### Step 3: Work Status Management
  - **Status Values**: Use WorkStatus enum values:
    - `CLAIMED`: Work has been claimed but not started
    - `IN_PROGRESS`: Actively working on the claim
    - `COMPLETED`: Work finished successfully
    - `FAILED`: Work encountered errors
    - `RELEASED`: Work was abandoned or reassigned

  #### Step 4: Update Work Progress
  - Update your work status automatically through the system
  - Status updates are tracked with timestamps
  - Other agents are notified of progress through the messaging system

  #### Step 5: Inter-Agent Communication
  - Send messages to coordinate with other agents:
    - Broadcast messages to all agents
    - Direct messages to specific agents
    - Message types: work_claim, work_release, status_update, help_request
  - Messages are stored in `agent_messages` table

  #### Step 6: Complete Work
  1. Update work status to `COMPLETED` or `FAILED`
  2. System logs completion in `completed_work` table with:
     - Files modified
     - Duration
     - Success status
     - Any error messages
  3. Work claims are automatically released

  ### Conflict Resolution:
  - **Automatic Detection**: System detects file conflicts before allowing work claims
  - **Stale Claim Cleanup**: Claims older than 2 hours are automatically released
  - **Load Balancing**: Work is distributed based on current agent workloads
  - **Priority System**: High-priority work can preempt lower-priority tasks

  ### Key Coordination Principles:
  1. **Trust the System**: The CoordinationManager handles most coordination automatically
  2. **Communicate Actively**: Use the messaging system to coordinate complex work
  3. **Update Status Frequently**: Keep your work status current for effective coordination
  4. **Respect Claims**: Never work on files claimed by other agents
  5. **Handle Failures Gracefully**: Update status to FAILED and release claims when encountering issues

  **Remember: We are working as a coordinated hive mind through the SQLite-based coordination system. The database handles conflict resolution, work distribution, and communication automatically. Stay organized, trust the system, and focus on your assigned work while the coordination layer manages the complex multi-agent orchestration.**
  
  Application Requirements:
  - Beautiful, responsive UI that follows platform guidelines
  - Smooth navigation and animations
  - Offline functionality with data sync
  - Push notifications
  - Camera and photo library integration
  - Location services
  - Secure local storage
  - API integration with backend
  
  Technology Stack:
  - React Native with TypeScript (or Flutter)
  - State management (Redux/MobX/Riverpod)
  - Navigation (React Navigation/Flutter Navigator)
  - Local database (SQLite/Realm)
  - Testing framework
  
  Agents should coordinate on shared components, state management, and API interfaces.

metadata:
  recommended_agents: 5
  recommended_mode: parallel
  estimated_time: 40
  difficulty: advanced
  tags: [mobile, react-native, flutter, ios, android, cross-platform]

steps:
  - content: Set up mobile development environment
    description: |
      Initialize the project:
      - Create React Native/Flutter project
      - Configure TypeScript/Dart
      - Set up iOS and Android builds
      - Configure development certificates
      - Install core dependencies
      - Set up debugging tools
      - Configure emulators/simulators
      - Create project structure
    
  - content: Design app architecture and navigation
    description: |
      Build navigation structure:
      - Implement tab navigation
      - Add stack navigation for screens
      - Create drawer navigation if needed
      - Set up deep linking
      - Implement navigation guards
      - Add transition animations
      - Create navigation service
      - Handle back button behavior
    
  - content: Create reusable UI components
    description: |
      Build component library:
      - Design system with colors and typography
      - Custom button components
      - Input fields with validation
      - Card and list components
      - Modal and dialog components
      - Loading and error states
      - Custom icons and assets
      - Platform-specific styling
    
  - content: Implement state management
    description: |
      Set up application state:
      - Configure Redux/MobX/Provider
      - Create store structure
      - Implement actions and reducers
      - Add middleware for async operations
      - Set up state persistence
      - Implement selectors/computed values
      - Add state debugging tools
      - Create state migrations
    
  - content: Build authentication flow
    description: |
      Create secure authentication:
      - Login and registration screens
      - Biometric authentication
      - Secure token storage
      - Auto-login functionality
      - Session management
      - Logout and cleanup
      - Password reset flow
      - Social login integration
    
  - content: Integrate camera and media
    description: |
      Add media capabilities:
      - Camera integration
      - Photo library access
      - Image cropping and editing
      - Video recording
      - Media upload with progress
      - Thumbnail generation
      - Gallery view component
      - Media compression
    
  - content: Implement location services
    description: |
      Add location features:
      - Request location permissions
      - Get current location
      - Background location tracking
      - Geofencing capabilities
      - Map integration
      - Location-based notifications
      - Address geocoding
      - Distance calculations
    
  - content: Add push notifications
    description: |
      Implement notifications:
      - Firebase Cloud Messaging setup
      - Request notification permissions
      - Handle foreground notifications
      - Background notification handling
      - Local notifications
      - Notification actions
      - Badge count management
      - Rich notifications with images
    
  - content: Create offline functionality
    description: |
      Implement offline support:
      - Local database setup (SQLite/Realm)
      - Data caching strategies
      - Offline queue for API calls
      - Sync mechanism when online
      - Conflict resolution
      - Offline indicators in UI
      - Data migration strategies
      - Cache invalidation
    
  - content: Build data synchronization
    description: |
      Create sync system:
      - Background sync service
      - Incremental sync logic
      - Full sync capabilities
      - Conflict resolution
      - Sync status indicators
      - Retry mechanisms
      - Data compression
      - Sync scheduling
    
  - content: Integrate with backend APIs
    description: |
      Connect to backend:
      - API client configuration
      - Request/response interceptors
      - Error handling
      - Token refresh logic
      - Request caching
      - Upload/download progress
      - WebSocket connections
      - GraphQL client (if applicable)
    
  - content: Implement app settings
    description: |
      Create settings screens:
      - User preferences
      - Notification settings
      - Privacy controls
      - Theme selection
      - Language selection
      - Cache management
      - Account settings
      - About and help screens
    
  - content: Add analytics and monitoring
    description: |
      Implement tracking:
      - Analytics SDK integration
      - User behavior tracking
      - Crash reporting (Sentry/Crashlytics)
      - Performance monitoring
      - Custom event tracking
      - User properties
      - Screen tracking
      - Error logging
    
  - content: Optimize performance
    description: |
      Enhance app performance:
      - Image lazy loading
      - List virtualization
      - Memory leak detection
      - Bundle size optimization
      - Startup time optimization
      - Animation performance
      - Reduce re-renders
      - Profile and optimize
    
  - content: Platform-specific features
    description: |
      Add native capabilities:
      - iOS widgets
      - Android widgets
      - App shortcuts
      - Share extensions
      - Today extensions
      - Apple Watch app
      - Android Wear support
      - Platform-specific UI
    
  - content: Implement security features
    description: |
      Add security measures:
      - Certificate pinning
      - Jailbreak/root detection
      - App obfuscation
      - Secure storage encryption
      - Screen recording prevention
      - Copy/paste restrictions
      - Biometric protection
      - Security audit
    
  - content: Create comprehensive testing
    description: |
      Test all features:
      - Unit tests for logic
      - Widget/component tests
      - Integration tests
      - E2E tests with Detox/Appium
      - Performance testing
      - Accessibility testing
      - Device compatibility testing
      - Network condition testing
    
  - content: Prepare for deployment
    description: |
      Ready for app stores:
      - App store assets (icons, screenshots)
      - Store descriptions
      - Privacy policy
      - App signing configuration
      - Build optimization
      - Beta testing setup
      - CI/CD pipeline
      - Release notes preparation