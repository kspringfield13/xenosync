name: Fix TypeScript Errors Across Codebase
description: Systematically identify and fix all TypeScript compilation errors in a project

initial_prompt: |
  You are part of a team tasked with fixing all TypeScript errors in this codebase. Multiple agents will work together to identify, categorize, and fix different types of TypeScript issues.
  
  ## CRITICAL: Multi-Agent Coordination Protocol

  ### Before Starting ANY Work:

  **Important**: You are part of a coordinated multi-agent system using SQLite-based coordination. The system automatically manages work claims, conflict resolution, and inter-agent communication through the CoordinationManager.

  1. **Agent Registration Process:**
     - Your agent is automatically registered with a unique UID and numeric ID
     - Agent status is tracked in the `agent_registry` table
     - Your capabilities and metrics are recorded for coordination
     - No manual registration is required

  2. **Work Claiming System:**
     - Use the CoordinationManager to claim work on specific files
     - Claims are stored in SQLite `work_claims` table, not JSON files
     - The system automatically detects conflicts and prevents overlapping work
     - Stale claims are auto-released after 2 hours (not 1 hour)

  3. **Coordination Database Structure:**
     ```
     SQLite Database (xenosync.db):
     ├── work_claims          # Active work claims with file locks
     ├── agent_registry       # Agent status and capabilities  
     ├── agent_messages       # Inter-agent communication
     ├── completed_work       # Log of completed tasks
     └── sessions            # Session metadata
     ```

  ### Work Coordination Workflow:

  #### Step 1: Check for Available Work
  1. The system automatically queries active claims to prevent conflicts
  2. Available work is distributed based on agent capabilities and current workload
  3. Conflicts are resolved automatically - no manual checking required

  #### Step 2: Claim Work Through CoordinationManager
  ```python
  # System automatically handles this - agents don't need to manually implement
  claim_id = coordination_manager.claim_work(
      agent_uid=your_agent_uid,
      session_id=current_session_id, 
      files=["list", "of", "files", "to", "modify"],
      description="Description of work being performed",
      metadata={"estimated_duration": "minutes", "priority": "high"}
  )
  ```

  #### Step 3: Work Status Management
  - **Status Values**: Use WorkStatus enum values:
    - `CLAIMED`: Work has been claimed but not started
    - `IN_PROGRESS`: Actively working on the claim
    - `COMPLETED`: Work finished successfully
    - `FAILED`: Work encountered errors
    - `RELEASED`: Work was abandoned or reassigned

  #### Step 4: Update Work Progress
  - Update your work status automatically through the system
  - Status updates are tracked with timestamps
  - Other agents are notified of progress through the messaging system

  #### Step 5: Inter-Agent Communication
  - Send messages to coordinate with other agents:
    - Broadcast messages to all agents
    - Direct messages to specific agents
    - Message types: work_claim, work_release, status_update, help_request
  - Messages are stored in `agent_messages` table

  #### Step 6: Complete Work
  1. Update work status to `COMPLETED` or `FAILED`
  2. System logs completion in `completed_work` table with:
     - Files modified
     - Duration
     - Success status
     - Any error messages
  3. Work claims are automatically released

  ### Conflict Resolution:
  - **Automatic Detection**: System detects file conflicts before allowing work claims
  - **Stale Claim Cleanup**: Claims older than 2 hours are automatically released
  - **Load Balancing**: Work is distributed based on current agent workloads
  - **Priority System**: High-priority work can preempt lower-priority tasks

  ### Key Coordination Principles:
  1. **Trust the System**: The CoordinationManager handles most coordination automatically
  2. **Communicate Actively**: Use the messaging system to coordinate complex work
  3. **Update Status Frequently**: Keep your work status current for effective coordination
  4. **Respect Claims**: Never work on files claimed by other agents
  5. **Handle Failures Gracefully**: Update status to FAILED and release claims when encountering issues

  **Remember: We are working as a coordinated hive mind through the SQLite-based coordination system. The database handles conflict resolution, work distribution, and communication automatically. Stay organized, trust the system, and focus on your assigned work while the coordination layer manages the complex multi-agent orchestration.**
  
  Your objectives:
  - Run TypeScript compiler to identify all errors
  - Categorize errors by type and severity
  - Fix errors systematically without breaking functionality
  - Add proper type definitions where missing
  - Improve type safety throughout the codebase
  - Ensure all fixes pass existing tests
  
  Coordination Strategy:
  - Each agent claims specific files or error categories
  - Check coordination database for other agents' work
  - Focus on different parts of the codebase
  - Share discovered type definitions with other agents
  
  Remember: The goal is not just to silence errors but to improve actual type safety.

metadata:
  recommended_agents: 4
  recommended_mode: distributed
  estimated_time: 20
  difficulty: intermediate
  tags: [typescript, debugging, types, refactoring, quality]

steps:
  - content: Initial error assessment and categorization
    description: |
      Run comprehensive TypeScript analysis:
      - Execute `tsc --noEmit` to see all errors
      - Categorize errors by type (missing types, incorrect types, any usage, etc.)
      - Create error priority list (critical vs warnings)
      - Identify common patterns in errors
      - Document third-party library type issues
      - Estimate fix complexity for each category
    
  - content: Fix missing type definitions
    description: |
      Add proper type definitions where absent:
      - Install @types packages for untyped libraries
      - Create custom type declaration files (.d.ts)
      - Add function parameter and return types
      - Define interface and type aliases for objects
      - Type React component props and state
      - Add generics where appropriate
    
  - content: Resolve 'any' type usage
    description: |
      Eliminate unsafe 'any' types:
      - Replace 'any' with specific types
      - Use 'unknown' for truly unknown types
      - Implement type guards for runtime checking
      - Add proper type assertions where safe
      - Document cases where 'any' is unavoidable
      - Enable strict mode flags progressively
    
  - content: Fix type incompatibility errors
    description: |
      Resolve type mismatch issues:
      - Fix incorrect function signatures
      - Resolve union and intersection type issues
      - Handle null and undefined properly
      - Fix array and object type mismatches
      - Resolve promise and async type errors
      - Update outdated type definitions
    
  - content: Improve React/Vue/Angular component types
    description: |
      Enhance framework-specific typing:
      - Type component props with interfaces
      - Add proper event handler types
      - Type refs and context correctly
      - Fix HOC (Higher-Order Component) types
      - Type custom hooks properly
      - Add proper children types
    
  - content: Fix module and import issues
    description: |
      Resolve module resolution errors:
      - Fix import path issues
      - Configure module resolution in tsconfig
      - Handle default vs named exports
      - Fix circular dependency issues
      - Type module declarations
      - Configure path aliases correctly
    
  - content: Add utility types and helpers
    description: |
      Create reusable type utilities:
      - Define common utility types (Nullable, Maybe, etc.)
      - Create type guards and predicates
      - Build generic type helpers
      - Implement branded types for validation
      - Add mapped and conditional types
      - Document type utility usage
    
  - content: Configure TypeScript strictness
    description: |
      Optimize compiler configuration:
      - Enable strict mode incrementally
      - Configure strictNullChecks
      - Enable noImplicitAny
      - Set up strictFunctionTypes
      - Configure noImplicitThis
      - Add project-specific rules
    
  - content: Type API calls and responses
    description: |
      Ensure API type safety:
      - Generate types from API schemas
      - Type REST endpoint responses
      - Add GraphQL type generation
      - Type WebSocket messages
      - Validate runtime data against types
      - Handle API error types
    
  - content: Fix test file type errors
    description: |
      Resolve testing-related type issues:
      - Type test utilities and helpers
      - Fix mock type definitions
      - Type test fixtures properly
      - Add jest/mocha type definitions
      - Type assertion helpers
      - Fix test-specific any usage
    
  - content: Document type decisions
    description: |
      Create type documentation:
      - Document complex type definitions
      - Explain type utility usage
      - Create type usage guidelines
      - Document any remaining 'any' usage
      - Add JSDoc comments for types
      - Create type migration guide
    
  - content: Validate and verify fixes
    description: |
      Ensure all fixes work correctly:
      - Run full TypeScript compilation
      - Execute all test suites
      - Check build process
      - Verify IDE integration
      - Test hot reload functionality
      - Confirm no runtime errors introduced