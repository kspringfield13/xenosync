name: Retro Pac-Man Style Arcade Game
description: Build a classic Pac-Man inspired arcade game with modern web technologies and retro aesthetics

initial_prompt: |
  You are building a Pac-Man style arcade game with authentic retro 8-bit aesthetics. This is a single-player maze navigation game where the player collects dots while avoiding ghosts.
  
  ## CRITICAL: Multi-Agent Coordination Protocol

  ### Before Starting ANY Work:

  **Important**: You are part of a coordinated multi-agent system using SQLite-based coordination. The system automatically manages work claims, conflict resolution, and inter-agent communication through the CoordinationManager.

  1. **Agent Registration Process:**
     - Your agent is automatically registered with a unique UID and numeric ID
     - Agent status is tracked in the `agent_registry` table
     - Your capabilities and metrics are recorded for coordination
     - No manual registration is required

  2. **Work Claiming System:**
     - Use the CoordinationManager to claim work on specific files
     - Claims are stored in SQLite `work_claims` table, not JSON files
     - The system automatically detects conflicts and prevents overlapping work
     - Stale claims are auto-released after 2 hours (not 1 hour)

  3. **Coordination Database Structure:**
     ```
     SQLite Database (xenosync.db):
     ├── work_claims          # Active work claims with file locks
     ├── agent_registry       # Agent status and capabilities  
     ├── agent_messages       # Inter-agent communication
     ├── completed_work       # Log of completed tasks
     └── sessions            # Session metadata
     ```

  ### Work Coordination Workflow:

  #### Step 1: Check for Available Work
  1. The system automatically queries active claims to prevent conflicts
  2. Available work is distributed based on agent capabilities and current workload
  3. Conflicts are resolved automatically - no manual checking required

  #### Step 2: Claim Work Through CoordinationManager
  ```python
  # System automatically handles this - agents don't need to manually implement
  claim_id = coordination_manager.claim_work(
      agent_uid=your_agent_uid,
      session_id=current_session_id, 
      files=["list", "of", "files", "to", "modify"],
      description="Description of work being performed",
      metadata={"estimated_duration": "minutes", "priority": "high"}
  )
  ```

  #### Step 3: Work Status Management
  - **Status Values**: Use WorkStatus enum values:
    - `CLAIMED`: Work has been claimed but not started
    - `IN_PROGRESS`: Actively working on the claim
    - `COMPLETED`: Work finished successfully
    - `FAILED`: Work encountered errors
    - `RELEASED`: Work was abandoned or reassigned

  #### Step 4: Update Work Progress
  - Update your work status automatically through the system
  - Status updates are tracked with timestamps
  - Other agents are notified of progress through the messaging system

  #### Step 5: Inter-Agent Communication
  - Send messages to coordinate with other agents:
    - Broadcast messages to all agents
    - Direct messages to specific agents
    - Message types: work_claim, work_release, status_update, help_request
  - Messages are stored in `agent_messages` table

  #### Step 6: Complete Work
  1. Update work status to `COMPLETED` or `FAILED`
  2. System logs completion in `completed_work` table with:
     - Files modified
     - Duration
     - Success status
     - Any error messages
  3. Work claims are automatically released

  ### Conflict Resolution:
  - **Automatic Detection**: System detects file conflicts before allowing work claims
  - **Stale Claim Cleanup**: Claims older than 2 hours are automatically released
  - **Load Balancing**: Work is distributed based on current agent workloads
  - **Priority System**: High-priority work can preempt lower-priority tasks

  ### Key Coordination Principles:
  1. **Trust the System**: The CoordinationManager handles most coordination automatically
  2. **Communicate Actively**: Use the messaging system to coordinate complex work
  3. **Update Status Frequently**: Keep your work status current for effective coordination
  4. **Respect Claims**: Never work on files claimed by other agents
  5. **Handle Failures Gracefully**: Update status to FAILED and release claims when encountering issues

  **Remember: We are working as a coordinated hive mind through the SQLite-based coordination system. The database handles conflict resolution, work distribution, and communication automatically. Stay organized, trust the system, and focus on your assigned work while the coordination layer manages the complex multi-agent orchestration.**
  
  The game should feature:
  - Classic maze gameplay with dot collection
  - Four unique ghosts with different AI behaviors
  - Power pellets that turn the tables on ghosts
  - Smooth grid-based movement and animations
  - Progressive difficulty with multiple levels
  - Bonus fruits for extra points
  - Lives system and high score tracking
  - Authentic arcade sound effects and visuals
  
  Technology Stack:
  - HTML5 Canvas for rendering
  - JavaScript/TypeScript for game logic
  - CSS for retro arcade cabinet styling
  - LocalStorage for high scores and progress
  - Web Audio API for classic arcade sounds
  
  Focus on creating an authentic arcade experience with smooth gameplay, intelligent ghost AI, and satisfying game feel.

metadata:
  recommended_agents: 3
  recommended_mode: parallel
  estimated_time: 30
  difficulty: intermediate
  tags: [game, arcade, pacman, canvas, javascript, retro, ai]

steps:
  - content: Set up the project structure and game framework
    description: |
      Create the foundational HTML5 game structure:
      - index.html with canvas element and arcade cabinet styling
      - CSS with retro arcade fonts and neon colors
      - Main game loop with requestAnimationFrame
      - Asset manager for sprites, sounds, and maze data
      - Game configuration and constants file
      - Basic file structure (js/, css/, assets/, sounds/)
    
  - content: Implement maze generation and rendering system
    description: |
      Build the maze infrastructure:
      - Create maze data structure (2D array or tile system)
      - Design classic Pac-Man style maze layout
      - Implement maze rendering with walls and paths
      - Add dot and power pellet placement logic
      - Create tunnel/warp zones on maze edges
      - Include ghost house in center of maze
      - Optimize rendering for performance
    
  - content: Create the player character (Pac-Man) mechanics
    description: |
      Develop the main character controls and behavior:
      - Grid-based movement with smooth animations
      - Keyboard controls (arrow keys and WASD)
      - Collision detection with walls
      - Dot and power pellet collection
      - Animated sprite with directional facing
      - Movement queuing for smoother control
      - Death animation and respawn logic
    
  - content: Implement dot collection and scoring system
    description: |
      Create the core collection mechanics:
      - Regular dots worth 10 points
      - Power pellets worth 50 points
      - Dot counter for level completion
      - Combo system for eating ghosts
      - Bonus fruit spawning (cherry, strawberry, orange)
      - Score display with retro font
      - High score tracking and display
      - Point popup animations
    
  - content: Build ghost AI with unique behaviors
    description: |
      Implement the four classic ghost personalities:
      - Blinky (red): Direct chase behavior
      - Pinky (pink): Ambush by targeting ahead of player
      - Inky (cyan): Unpredictable, uses Blinky's position
      - Clyde (orange): Chase when far, scatter when close
      - Scatter mode where ghosts patrol corners
      - Chase mode with increasing aggression
      - Frightened mode when power pellet eaten
      - Pathfinding algorithm (A* or simplified)
      - Ghost house exit logic and timing
    
  - content: Create power-up and ghost vulnerability system
    description: |
      Implement power pellet mechanics:
      - Timer-based ghost vulnerability
      - Blue/white flashing frightened ghosts
      - Reversed ghost movement when frightened
      - Points for eating ghosts (200, 400, 800, 1600)
      - Ghost eyes returning to house after eaten
      - Power-up duration decreases with level
      - Warning flash before power-up ends
      - Sound cues for power-up state
    
  - content: Develop visual effects and animations
    description: |
      Create the retro arcade presentation:
      - Pixel-perfect sprite animations
      - Classic arcade color palette
      - Smooth movement interpolation
      - Death animations for Pac-Man
      - Ghost animation states (normal, frightened, eyes)
      - Particle effects for dot collection
      - Screen flash effects for power-ups
      - Arcade CRT screen effect overlay
      - Attract mode demo when idle
    
  - content: Implement audio and sound effects system
    description: |
      Create authentic arcade audio:
      - Classic wakka-wakka eating sound
      - Ghost siren that increases with tension
      - Power pellet activation sound
      - Ghost eaten chomping sound
      - Death jingle for losing a life
      - Level complete fanfare
      - Bonus fruit collection sounds
      - Retro intro music
      - Volume controls and mute option
    
  - content: Build game states and UI systems
    description: |
      Create game flow and interface:
      - Start screen with arcade attract mode
      - Ready message before level start
      - Pause functionality
      - Game over screen with final score
      - Level transitions with brief intermission
      - Lives display (3 lives to start)
      - Current level indicator
      - Settings menu for difficulty
      - Instructions/how to play screen
      - Credits screen
    
  - content: Create comprehensive game documentation
    description: |
      Generate a detailed GAME_README.md file that includes:
      
      # Installation & Setup
      - Prerequisites and dependencies
      - How to download/clone the game
      - Running locally (python -m http.server, live-server, etc.)
      - Browser compatibility notes
      
      # How to Play
      - Game controls (Arrow keys/WASD)
      - Objective and win conditions
      - Scoring system explanation
      - Ghost behaviors and strategies
      - Power-up mechanics
      - Level progression
      
      # Customization Guide
      - Modifying maze layouts (maze editor tips)
      - Adjusting difficulty settings
      - Changing ghost AI parameters
      - Customizing sprites and colors
      - Adding new sound effects
      - Creating custom levels
      
      # Code Structure
      - File organization overview
      - Key classes: Game, Player, Ghost, Maze
      - Game loop explanation
      - AI algorithm details
      - Collision detection system
      
      # Enhancement Ideas
      - Add two-player mode
      - Create online leaderboards
      - Implement save states
      - Add new ghost types
      - Create bonus stages
      - Mobile touch controls
      - Level editor tool
      - Multiplayer networking
      - Achievement system
      - Custom maze generator
      
      # Troubleshooting
      - Common issues and fixes
      - Performance optimization tips
      - Debug mode instructions
      
      Make this documentation user-friendly and comprehensive!