name: Retro Pac-Man Style Arcade Game
description: Build a classic Pac-Man inspired arcade game with modern web technologies and retro aesthetics

initial_prompt: |
  You are building a Pac-Man style arcade game with authentic retro 8-bit aesthetics. This is a single-player maze navigation game where the player collects dots while avoiding ghosts.

  The game should feature:
  - Classic maze gameplay with dot collection
  - Four unique ghosts with different AI behaviors
  - Power pellets that turn the tables on ghosts
  - Smooth grid-based movement and animations
  - Progressive difficulty with multiple levels
  - Bonus fruits for extra points
  - Lives system and high score tracking
  - Authentic arcade sound effects and visuals
  
  Technology Stack:
  - HTML5 Canvas for rendering
  - JavaScript/TypeScript for game logic
  - CSS for retro arcade cabinet styling
  - LocalStorage for high scores and progress
  - Web Audio API for classic arcade sounds
  
  TESTING PHILOSOPHY:
  - Test early, test often - don't wait until the end to validate your work
  - Every feature should be tested as soon as it's implemented
  - Test in multiple browsers (Chrome, Firefox, Safari, Edge)
  - Verify game mechanics work smoothly at 60fps
  - Test edge cases: collision detection, maze boundaries, ghost transitions
  - Validate user experience: controls feel responsive, game is fun to play
  - Document any bugs found and ensure they're fixed before moving on
  
  Focus on creating an authentic arcade experience with smooth gameplay, intelligent ghost AI, and satisfying game feel. Remember: a working, thoroughly tested game is always better than an incomplete feature-rich one.

metadata:
  recommended_agents: 3
  recommended_mode: parallel
  estimated_time: 30
  difficulty: intermediate
  tags: [game, arcade, pacman, canvas, javascript, retro, ai]

steps:
  - content: Set up the project structure and game framework
    description: |
      Create the foundational HTML5 game structure:
      - index.html with canvas element and arcade cabinet styling
      - CSS with retro arcade fonts and neon colors
      - Main game loop with requestAnimationFrame
      - Asset manager for sprites, sounds, and maze data
      - Game configuration and constants file
      - Basic file structure (js/, css/, assets/, sounds/)
    
  - content: Implement maze generation and rendering system
    description: |
      Build the maze infrastructure:
      - Create maze data structure (2D array or tile system)
      - Design classic Pac-Man style maze layout
      - Implement maze rendering with walls and paths
      - Add dot and power pellet placement logic
      - Create tunnel/warp zones on maze edges
      - Include ghost house in center of maze
      - Optimize rendering for performance
    
  - content: Create the player character (Pac-Man) mechanics
    description: |
      Develop the main character controls and behavior:
      - Grid-based movement with smooth animations
      - Keyboard controls (arrow keys and WASD)
      - Collision detection with walls
      - Dot and power pellet collection
      - Animated sprite with directional facing
      - Movement queuing for smoother control
      - Death animation and respawn logic
    
  - content: Implement dot collection and scoring system
    description: |
      Create the core collection mechanics:
      - Regular dots worth 10 points
      - Power pellets worth 50 points
      - Dot counter for level completion
      - Combo system for eating ghosts
      - Bonus fruit spawning (cherry, strawberry, orange)
      - Score display with retro font
      - High score tracking and display
      - Point popup animations
    
  - content: Test core game mechanics and player experience
    description: |
      Comprehensive testing of implemented features:
      - Verify Pac-Man movement in all directions
      - Test collision detection with walls and maze boundaries
      - Confirm dot collection works correctly and updates score
      - Validate power pellet collection and scoring
      - Test level completion when all dots are collected
      - Verify score display updates in real-time
      - Test high score saving and loading from LocalStorage
      - Check game runs smoothly at 60fps in all target browsers
      - Test keyboard responsiveness (arrow keys and WASD)
      - Verify movement queuing works for smooth control
      - Test death animation and respawn mechanics
      - Document any performance issues or bugs found
      - Fix all identified issues before proceeding to ghost AI
    
  - content: Build ghost AI with unique behaviors
    description: |
      Implement the four classic ghost personalities:
      - Blinky (red): Direct chase behavior
      - Pinky (pink): Ambush by targeting ahead of player
      - Inky (cyan): Unpredictable, uses Blinky's position
      - Clyde (orange): Chase when far, scatter when close
      - Scatter mode where ghosts patrol corners
      - Chase mode with increasing aggression
      - Frightened mode when power pellet eaten
      - Pathfinding algorithm (A* or simplified)
      - Ghost house exit logic and timing
    
  - content: Create power-up and ghost vulnerability system
    description: |
      Implement power pellet mechanics:
      - Timer-based ghost vulnerability
      - Blue/white flashing frightened ghosts
      - Reversed ghost movement when frightened
      - Points for eating ghosts (200, 400, 800, 1600)
      - Ghost eyes returning to house after eaten
      - Power-up duration decreases with level
      - Warning flash before power-up ends
      - Sound cues for power-up state
    
  - content: Integration testing of AI and game systems
    description: |
      Comprehensive testing of all game mechanics working together:
      - Test all four ghost AI behaviors in various scenarios
      - Verify ghost pathfinding works correctly in all maze areas
      - Test power pellet activation and ghost state transitions
      - Confirm ghost vulnerability timer works as expected
      - Test eating ghosts and score multiplier progression (200→400→800→1600)
      - Verify ghost eyes return to house correctly after being eaten
      - Test ghost house exit logic and timing
      - Confirm scatter/chase mode transitions work properly
      - Test edge cases: player-ghost collisions, tunnel warping, maze corners
      - Verify game performance with all AI running simultaneously
      - Test level progression and ghost speed increases
      - Confirm power pellet duration decreases with level advancement
      - Test player death scenarios and life system
      - Validate all game states work correctly (ready, playing, paused, game over)
      - Document any AI behavior issues or performance problems
      - Fix all identified issues before proceeding to visual effects
    
  - content: Develop visual effects and animations
    description: |
      Create the retro arcade presentation:
      - Pixel-perfect sprite animations
      - Classic arcade color palette
      - Smooth movement interpolation
      - Death animations for Pac-Man
      - Ghost animation states (normal, frightened, eyes)
      - Particle effects for dot collection
      - Screen flash effects for power-ups
      - Arcade CRT screen effect overlay
      - Attract mode demo when idle
    
  - content: Implement audio and sound effects system
    description: |
      Create authentic arcade audio:
      - Classic wakka-wakka eating sound
      - Ghost siren that increases with tension
      - Power pellet activation sound
      - Ghost eaten chomping sound
      - Death jingle for losing a life
      - Level complete fanfare
      - Bonus fruit collection sounds
      - Retro intro music
      - Volume controls and mute option
    
  - content: Build game states and UI systems
    description: |
      Create game flow and interface:
      - Start screen with arcade attract mode
      - Ready message before level start
      - Pause functionality
      - Game over screen with final score
      - Level transitions with brief intermission
      - Lives display (3 lives to start)
      - Current level indicator
      - Settings menu for difficulty
      - Instructions/how to play screen
      - Credits screen
    
  - content: Final comprehensive testing and validation
    description: |
      Complete end-to-end testing of the finished game:
      - Full gameplay testing: Complete multiple levels from start to finish
      - Cross-browser compatibility testing (Chrome, Firefox, Safari, Edge)
      - Performance testing: Confirm smooth 60fps gameplay on various devices
      - User experience testing: Ensure controls feel responsive and intuitive
      - Audio testing: Verify all sounds work correctly and enhance gameplay
      - Visual testing: Confirm all animations and effects work as expected
      - State management testing: Test all transitions (start→play→pause→game over)
      - Persistence testing: Verify high scores save/load correctly
      - Edge case testing: Tunnel warping, simultaneous collisions, rapid inputs
      - Accessibility testing: Keyboard navigation, color contrast, screen readers
      - Mobile device testing: Touch controls (if implemented), responsive design
      - Load testing: Game startup performance, asset loading times
      - Stress testing: Extended gameplay sessions, memory usage monitoring
      - Bug regression testing: Verify all previously found issues are resolved
      - Final quality assurance: Game is fun, balanced, and ready for release
      - Document all test results, performance benchmarks, and known limitations
      - Create troubleshooting guide based on testing findings
    
  - content: Create comprehensive game documentation
    description: |
      Generate a detailed GAME_README.md file that includes:
      
      # Installation & Setup
      - Prerequisites and dependencies
      - How to download/clone the game
      - Running locally (python3 -m http.server)
      - Browser compatibility notes
      
      # How to Play
      - Game controls (Arrow keys/WASD)
      - Objective and win conditions
      - Scoring system explanation
      - Ghost behaviors and strategies
      - Power-up mechanics
      - Level progression
      
      # Customization Guide
      - Modifying maze layouts (maze editor tips)
      - Adjusting difficulty settings
      - Changing ghost AI parameters
      - Customizing sprites and colors
      - Adding new sound effects
      - Creating custom levels
      
      # Code Structure
      - File organization overview
      - Key classes: Game, Player, Ghost, Maze
      - Game loop explanation
      - AI algorithm details
      - Collision detection system
      
      # Testing Results & Quality Assurance
      - Browser compatibility matrix (tested versions)
      - Performance benchmarks (fps, memory usage, load times)
      - Known limitations and workarounds
      - Test coverage summary for all game features
      - User acceptance testing feedback
      - Accessibility compliance status
      
      # Enhancement Ideas
      - Add two-player mode
      - Create online leaderboards
      - Implement save states
      - Add new ghost types
      - Create bonus stages
      - Mobile touch controls
      - Level editor tool
      - Multiplayer networking
      - Achievement system
      - Custom maze generator
      
      # Troubleshooting & Support
      - Common issues and fixes (based on testing findings)
      - Browser-specific compatibility issues
      - Performance optimization tips
      - Debug mode instructions
      - Audio/video troubleshooting
      - Input lag solutions
      - Frame rate optimization
      - Memory leak prevention
      - Mobile device issues
      - LocalStorage problems
      
      Make this documentation user-friendly and comprehensive!